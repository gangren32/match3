<!--
ИНСТРУКЦИЯ ПО НАСТРОЙКЕ:
- Размер поля: BOARD_ROWS и BOARD_COLS (по умолчанию 8x8).
- Размер логической плитки: TILE_SIZE (по умолчанию 64). Отображение масштабируется автоматически под экран (в т.ч. iPhone 15 Pro).
- Количество типов фишек: TILE_TYPES (по умолчанию 6).
- Цели режимов: TARGET_SCORE (по ходам), MOVES_COUNT — число ходов, TIMED_SECONDS — длительность режима по времени.
- Подсказка: HINT_DELAY_MS — задержка появления.
Лицензия: весь код и встроенные ассеты — CC0/MIT.
-->
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="default" />
<meta name="format-detection" content="telephone=no" />
<meta name="color-scheme" content="light dark" />
<title>3 в ряд</title>
<style>
  :root{
    --bg:#ffffff; --fg:#111111; --muted:#666; --panel:#f2f2f2; --accent:#0072B2;
    --tile1:#E69F00; --tile2:#56B4E9; --tile3:#009E73; --tile4:#F0E442; --tile5:#0072B2; --tile6:#D55E00;
    --board-shadow: 0 8px 24px rgba(0,0,0,.12);
    --transition: 200ms;
    --rows:8; --cols:8; --tile:64px;
  }
  @media (prefers-color-scheme: dark){
    :root{ --bg:#0f1115; --fg:#f5f7fb; --muted:#a3a7b3; --panel:#171a21; --board-shadow: 0 8px 24px rgba(0,0,0,.5); }
  }
  html[data-theme="light"]{ color-scheme: light; --bg:#ffffff; --fg:#111; --muted:#666; --panel:#f2f2f2; --board-shadow:0 8px 24px rgba(0,0,0,.12) }
  html[data-theme="dark"]{ color-scheme: dark; --bg:#0f1115; --fg:#f5f7fb; --muted:#a3a7b3; --panel:#171a21; --board-shadow:0 8px 24px rgba(0,0,0,.5) }

  *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Ubuntu, "Helvetica Neue", Arial;
    display:flex; min-height:100dvh; flex-direction:column; align-items:center; gap:12px;
  }
  header{
    width:100%; max-width:1024px; padding: calc(env(safe-area-inset-top) + 10px) clamp(10px,4vw,24px) 10px;
    display:flex; align-items:center; justify-content:space-between; gap:10px; background:var(--panel); position:sticky; top:0; z-index:5;
    box-shadow: 0 2px 8px rgba(0,0,0,.08);
  }
  .top-left,.top-right{ display:flex; align-items:center; gap:8px; flex-wrap:wrap }
  .stat{ padding:6px 10px; border-radius:12px; background:transparent; display:flex; gap:6px; align-items:center }
  .stat b{ font-weight:700 }
  .btn{
    border:1px solid rgba(127,127,127,.25); background:var(--bg); color:var(--fg);
    padding:10px 14px; border-radius:14px; cursor:pointer; user-select:none;
    font-size:15px; line-height:1; transition:transform .06s ease, background .2s, border-color .2s;
    touch-action: manipulation;
  }
  .btn:active{ transform: translateY(1px) scale(.98) }
  .btn.primary{ border-color:transparent; background:var(--accent); color:#fff }
  .btn.toggle[aria-pressed="true"]{ background:var(--accent); color:#fff }
  .wrap{ width:100%; max-width:1024px; display:grid; place-items:center; padding: 8px clamp(10px,4vw,24px) 24px }
  .board-shell{
    width: min(96vw, calc(var(--tile)*var(--cols) + 24px));
    aspect-ratio: 1 / 1; background:var(--panel); border-radius:24px; padding:12px;
    box-shadow: var(--board-shadow); position:relative; overflow:hidden; display:grid; place-items:center;
  }
  .board{
    width: calc(var(--tile) * var(--cols)); height: calc(var(--tile) * var(--rows));
    touch-action: none; /* критично для свайпа на iOS */
  }
  /* Тайлы */
  .tile{ transition: transform var(--transition) ease, opacity var(--transition) ease; will-change: transform, opacity; cursor:pointer; }
  .tile .ring{ opacity:0; transition: opacity .12s ease }
  .tile:focus-visible .ring, .tile.selected .ring{ opacity:1 }
  .hint{ animation: m3-pulse 1.5s ease-in-out infinite }
  @keyframes m3-pulse{ 0%{filter:none} 50%{filter: drop-shadow(0 0 10px rgba(0,114,178,.9))} 100%{filter:none} }
  .shake{ animation: m3-shake .25s ease }
  @keyframes m3-shake{
    0%{ transform: translate(var(--x), var(--y)) }
    25%{ transform: translate(calc(var(--x) + 6px), var(--y)) }
    50%{ transform: translate(calc(var(--x) - 6px), var(--y)) }
    75%{ transform: translate(calc(var(--x) + 4px), var(--y)) }
    100%{ transform: translate(var(--x), var(--y)) }
  }
  /* Оверлеи */
  .overlay{ position:absolute; inset:0; background:rgba(0,0,0,.5); display:none; place-items:center; z-index:10 }
  .overlay.show{ display:grid }
  .card{ background:var(--bg); color:var(--fg); padding:16px; border-radius:16px; width:min(92vw,520px); box-shadow:var(--board-shadow) }
  .card h2{ margin:0 0 8px }
  .settings-grid{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center }
  .switch{ display:inline-flex; align-items:center; gap:8px }
  .switch input{ width:42px; height:24px; appearance:none; background:#aab; border-radius:999px; position:relative; outline:none; cursor:pointer; transition:background .2s }
  .switch input:checked{ background:var(--accent) }
  .switch input::after{ content:""; position:absolute; inset:3px auto auto 3px; width:18px; height:18px; border-radius:50%; background:#fff; transition: transform .2s }
  .switch input:checked::after{ transform: translateX(18px) }
  .sr-only{ position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }
  footer{ color:var(--muted); padding: 0 clamp(10px,4vw,24px) calc(env(safe-area-inset-bottom) + 16px) }

  /* Адаптация: автоматически подгоняем размер тайла под ширину экрана (включая iPhone 15 Pro) */
  @media (max-width: 480px){
    :root{ --tile: min(68px, calc((100vw - 48px) / var(--cols))) }
    .btn{ padding:10px 12px }
    .stat{ padding:4px 8px }
  }
</style>
</head>
<body>
<header aria-label="Панель управления">
  <div class="top-left">
    <div class="stat" aria-live="polite"><span>Счёт:</span> <b id="score">0</b></div>
    <div class="stat" id="goalBox"><span id="goalLabel">Цель:</span> <b id="goal">500</b></div>
    <div class="stat" id="movesBox"><span>Ходов:</span> <b id="moves">30</b></div>
    <div class="stat" id="timeBox" style="display:none"><span>Время:</span> <b id="time">02:00</b></div>
    <div class="stat"><span>Лучший:</span> <b id="best">0</b></div>
  </div>
  <div class="top-right">
    <button class="btn primary" id="newGameBtn">Новая игра</button>
    <button class="btn" id="pauseBtn" aria-pressed="false">Пауза</button>
    <button class="btn" id="settingsBtn">Настройки</button>
    <button class="btn toggle" id="soundBtn" aria-pressed="true">Звук: Вкл</button>
  </div>
</header>

<div class="wrap">
  <div class="board-shell">
    <svg id="board" class="board" role="grid" tabindex="0" aria-label="Игровое поле"></svg>

    <div class="overlay" id="pauseOverlay" role="dialog" aria-modal="true" aria-labelledby="pauseTitle">
      <div class="card">
        <h2 id="pauseTitle">Пауза</h2>
        <div style="display:flex; justify-content:flex-end; gap:8px">
          <button class="btn" id="resumeBtn">Продолжить</button>
        </div>
      </div>
    </div>

    <div class="overlay" id="helpOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
      <div class="card">
        <h2 id="helpTitle">Как играть</h2>
        <p>Собирайте 3+ фишек одного цвета по горизонтали или вертикали.</p>
        <p>Свайпните фишку (тач) или кликните две соседние (мышь) для обмена. Клавиатура: стрелки + Enter/Пробел.</p>
        <p>Комбинации: 4 — полосатая (линия), 5 — бомба цвета, Т/Г — бомба 3×3. Бонусы можно комбинировать.</p>
        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:8px">
          <label class="switch"><input type="checkbox" id="dontShowHelp"><span>Больше не показывать</span></label>
          <button class="btn" id="helpOk">Понятно</button>
        </div>
      </div>
    </div>

    <div class="overlay" id="settingsOverlay" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <div class="card">
        <h2 id="settingsTitle">Настройки</h2>
        <div class="settings-grid" style="margin-top:8px">
          <div>Режим</div>
          <div>
            <select id="modeSelect" aria-label="Режим">
              <option value="moves">По ходам</option>
              <option value="timed">По времени</option>
            </select>
          </div>
          <div>Тема</div>
          <div>
            <select id="themeSelect" aria-label="Тема">
              <option value="system">Системная</option>
              <option value="light">Светлая</option>
              <option value="dark">Тёмная</option>
            </select>
          </div>
          <div>Звук</div>
          <div class="switch"><input type="checkbox" id="soundToggle" checked></div>
        </div>
        <div style="display:flex; justify-content:flex-end; margin-top:12px">
          <button class="btn" id="settingsClose">Понятно</button>
        </div>
      </div>
    </div>

    <div class="overlay" id="overOverlay" role="dialog" aria-modal="true" aria-labelledby="overTitle">
      <div class="card">
        <h2 id="overTitle">Итог</h2>
        <p id="overText">Победа!</p>
        <div style="display:flex; justify-content:flex-end">
          <button class="btn primary" id="overNew">Новая игра</button>
        </div>
      </div>
    </div>

  </div>
</div>
<footer aria-hidden="true">© CC0/MIT • Офлайн один файл • Адаптировано под iPhone 15 Pro и мобильные</footer>

<script>
/* =========================
   КОНСТАНТЫ
========================= */
const BOARD_ROWS = 8;
const BOARD_COLS = 8;
const TILE_SIZE = 64; // логический размер; визуально масштабируется через CSS
const TILE_TYPES = 6;
const TARGET_SCORE = 500;
const MOVES_COUNT = 30;
const TIMED_SECONDS = 120;
const HINT_DELAY_MS = 5000;
const TRANSITION_MS = 200;
const SCORE_BASE3 = 10;
const SCORE_EXTRA = 5;
const SCORE_POWERUP = 50;

/* =========================
   СОСТОЯНИЕ
========================= */
const Type = { NORMAL:'n', STRIPED_H:'sh', STRIPED_V:'sv', BOMB_3:'b3', COLOR:'cb' };
let state = {
  mode: 'moves',
  score: 0, best: 0, target: TARGET_SCORE,
  movesLeft: MOVES_COUNT, timeLeft: TIMED_SECONDS,
  paused: false, inputLocked: false,
  selected: null, hintTimer: null, hintPair: null,
  board: [], tilesById: new Map(), idGen:1,
  cascade:0, soundOn:true, theme:'system',
  rngSeed: Date.now() & 0x7fffffff,
  drag: { id:null, startRC:null, startX:0, startY:0, didSwap:false }
};

/* =========================
   УТИЛИТЫ
========================= */
function rng(){ state.rngSeed = (1103515245*state.rngSeed + 12345) & 0x7fffffff; return state.rngSeed/0x80000000; }
function rint(n){ return (rng()*n)|0; }
function inB(r,c){ return r>=0 && c>=0 && r<BOARD_ROWS && c<BOARD_COLS; }
function neighbors(rc){ return [{r:rc.r-1,c:rc.c},{r:rc.r+1,c:rc.c},{r:rc.r,c:rc.c-1},{r:rc.r,c:rc.c+1}].filter(p=>inB(p.r,p.c)); }
function el(id){ return document.getElementById(id); }
function setVars(){ document.documentElement.style.setProperty('--rows', BOARD_ROWS); document.documentElement.style.setProperty('--cols', BOARD_COLS); document.documentElement.style.setProperty('--tile', TILE_SIZE+'px'); }
function tfmt(s){ s=Math.max(0,s|0); const m=(s/60|0).toString().padStart(2,'0'); const ss=(s%60).toString().padStart(2,'0'); return m+':'+ss; }
function save(){ localStorage.setItem('m3_best',state.best); localStorage.setItem('m3_mode',state.mode); localStorage.setItem('m3_theme',state.theme); localStorage.setItem('m3_sound',state.soundOn?'on':'off'); }
function load(){ state.best=parseInt(localStorage.getItem('m3_best')||'0',10); state.mode=localStorage.getItem('m3_mode')||'moves'; state.theme=localStorage.getItem('m3_theme')||'system'; state.soundOn=(localStorage.getItem('m3_sound')||'on')==='on'; }
function applyTheme(){ if(state.theme==='system') document.documentElement.removeAttribute('data-theme'); else document.documentElement.setAttribute('data-theme',state.theme); }
function setStatus(){ el('score').textContent=state.score; el('best').textContent=state.best; el('moves').textContent=state.movesLeft; el('time').textContent=tfmt(state.timeLeft); }
function tileLabel(t){ let s='фишка '+(t.kind+1); if(t.type===Type.STRIPED_H) s+=', полосатая гор.'; if(t.type===Type.STRIPED_V) s+=', полосатая верт.'; if(t.type===Type.BOMB_3) s+=', бомба 3×3'; if(t.type===Type.COLOR) s+=', бомба цвета'; return s; }
const palette = [getCSS('--tile1','#E69F00'),getCSS('--tile2','#56B4E9'),getCSS('--tile3','#009E73'),getCSS('--tile4','#F0E442'),getCSS('--tile5','#0072B2'),getCSS('--tile6','#D55E00')];
function getCSS(name, fallback){ const v=getComputedStyle(document.documentElement).getPropertyValue(name).trim(); return v||fallback; }
function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }
function next2frames(){ return new Promise(res=>requestAnimationFrame(()=>requestAnimationFrame(res))); }

/* =========================
   ЗВУК (WebAudio, дружественный к iOS)
========================= */
let audioCtx=null;
function ensureAudio(){ if(!audioCtx){ try{ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }catch(_){} } }
function beep({f=450,d=0.08,w='sine',g=0.03}={}){ if(!state.soundOn||!audioCtx) return; const t=audioCtx.currentTime; const o=audioCtx.createOscillator(); const gi=audioCtx.createGain(); o.type=w; o.frequency.value=f; gi.gain.setValueAtTime(0,t); gi.gain.linearRampToValueAtTime(g,t+0.01); gi.gain.exponentialRampToValueAtTime(0.0001,t+d); o.connect(gi).connect(audioCtx.destination); o.start(t); o.stop(t+d+0.02); }
const sfx = { click:()=>beep({f:270,w:'triangle',d:0.06}), swap:()=>beep({f:320,w:'sawtooth'}), bad:()=>{beep({f:180,w:'square'}); setTimeout(()=>beep({f:120,w:'square'}),60)}, match:(c=0)=>beep({f:430+c*40,w:'triangle'}), cascade:(n)=>beep({f:520+n*60,w:'sine',d:0.1,g:0.04}), button:()=>beep({f:540,w:'triangle',d:0.05}) };

/* =========================
   РЕНДЕР (SVG)
========================= */
const svgNS='http://www.w3.org/2000/svg';
const board = el('board');

function createTile(kind,type=Type.NORMAL){ const id=state.idGen++; const t={id,kind,type,r:-1,c:-1,el:null,x:0,y:0,removing:false}; state.tilesById.set(id,t); return t; }
function mountTile(t,r,c){
  t.r=r; t.c=c; t.x=c*TILE_SIZE; t.y=r*TILE_SIZE;
  const g=document.createElementNS(svgNS,'g'); g.classList.add('tile'); g.setAttribute('data-id',t.id); g.setAttribute('role','gridcell'); g.setAttribute('tabindex','0'); g.setAttribute('aria-label',tileLabel(t));
  const rect=document.createElementNS(svgNS,'rect'); rect.setAttribute('x',4); rect.setAttribute('y',4); rect.setAttribute('rx',14); rect.setAttribute('ry',14); rect.setAttribute('width',TILE_SIZE-8); rect.setAttribute('height',TILE_SIZE-8); rect.setAttribute('fill','#0000');
  const gem=drawGem(t);
  const ring=document.createElementNS(svgNS,'rect'); ring.setAttribute('class','ring'); ring.setAttribute('x',2); ring.setAttribute('y',2); ring.setAttribute('rx',16); ring.setAttribute('ry',16); ring.setAttribute('width',TILE_SIZE-4); ring.setAttribute('height',TILE_SIZE-4); ring.setAttribute('stroke','#0072B2'); ring.setAttribute('stroke-width','3'); ring.setAttribute('fill','none');
  g.append(rect, gem, ring); board.appendChild(g); t.el=g; place(t);
  attachTileInput(g,t);
}
function drawGem(t){
  const g=document.createElementNS(svgNS,'g'); const base=document.createElementNS(svgNS,'circle'); base.setAttribute('cx',TILE_SIZE/2); base.setAttribute('cy',TILE_SIZE/2); base.setAttribute('r',TILE_SIZE*0.28); base.setAttribute('fill', t.type===Type.COLOR ? '#333' : palette[t.kind%TILE_TYPES]); base.setAttribute('stroke','#0005'); base.setAttribute('stroke-width',2); g.appendChild(base);
  if(t.type===Type.STRIPED_H||t.type===Type.STRIPED_V){
    for(let i=-2;i<=2;i++){ const r=document.createElementNS(svgNS,'rect'); if(t.type===Type.STRIPED_H){ r.setAttribute('x', TILE_SIZE*0.2*(i+3)-6); r.setAttribute('y', TILE_SIZE*0.28-6); r.setAttribute('width',12); r.setAttribute('height',12); r.setAttribute('transform',`rotate(45 ${TILE_SIZE/2} ${TILE_SIZE/2})`); } else { r.setAttribute('x', TILE_SIZE*0.28-6); r.setAttribute('y', TILE_SIZE*0.2*(i+3)-6); r.setAttribute('width',12); r.setAttribute('height',12); r.setAttribute('transform',`rotate(45 ${TILE_SIZE/2} ${TILE_SIZE/2})`); } r.setAttribute('fill','#fff'); r.setAttribute('opacity','0.75'); g.appendChild(r); }
  }
  if(t.type===Type.BOMB_3){ const sq=document.createElementNS(svgNS,'rect'); sq.setAttribute('x',TILE_SIZE/2-TILE_SIZE*0.18); sq.setAttribute('y',TILE_SIZE/2-TILE_SIZE*0.18); sq.setAttribute('width',TILE_SIZE*0.36); sq.setAttribute('height',TILE_SIZE*0.36); sq.setAttribute('rx',6); sq.setAttribute('fill','#fff'); sq.setAttribute('opacity','0.9'); g.appendChild(sq); }
  if(t.type===Type.COLOR){ for(let i=0;i<6;i++){ const st=document.createElementNS(svgNS,'circle'); const a=i*Math.PI*2/6; st.setAttribute('cx',TILE_SIZE/2+Math.cos(a)*TILE_SIZE*0.18); st.setAttribute('cy',TILE_SIZE/2+Math.sin(a)*TILE_SIZE*0.18); st.setAttribute('r',3); st.setAttribute('fill','#fff'); g.appendChild(st);} }
  return g;
}
function refreshGem(t){ if(!t.el) return; const old=t.el.children[1]; t.el.removeChild(old); t.el.insertBefore(drawGem(t), t.el.children[1]); t.el.setAttribute('aria-label',tileLabel(t)); }
function place(t){ const x=t.c*TILE_SIZE, y=t.r*TILE_SIZE; t.x=x; t.y=y; t.el.style.setProperty('--x',x+'px'); t.el.style.setProperty('--y',y+'px'); t.el.style.transform=`translate(${x}px, ${y}px)`; }
function removeTile(t){ t.removing=true; t.el.style.opacity='0'; setTimeout(()=>{ if(t.el?.parentNode===board) board.removeChild(t.el); t.el=null; }, TRANSITION_MS); }

/* =========================
   ГЕНЕРАЦИЯ ПОЛЯ
========================= */
function emptyBoard(){ state.board = Array.from({length:BOARD_ROWS},()=>Array(BOARD_COLS).fill(null)); }
function randKind(){ return rint(TILE_TYPES); }

function generateBoard(){
  emptyBoard();
  for(let r=0;r<BOARD_ROWS;r++){
    for(let c=0;c<BOARD_COLS;c++){
      let k, tries=0;
      do{
        k=randKind(); tries++;
      }while((c>=2 && state.board[r][c-1]?.kind===k && state.board[r][c-2]?.kind===k) ||
             (r>=2 && state.board[r-1][c]?.kind===k && state.board[r-2][c]?.kind===k));
      const t=createTile(k); state.board[r][c]=t; mountTile(t,r,c);
    }
  }
  let guard=0;
  while(!findAnyMove() && guard<50){ reshuffle(); guard++; }
}
function reshuffle(){
  for(let r=0;r<BOARD_ROWS;r++){
    for(let c=0;c<BOARD_COLS;c++){
      let k; do{
        k=randKind();
      }while((c>=2 && state.board[r][c-1]?.kind===k && state.board[r][c-2]?.kind===k) ||
             (r>=2 && state.board[r-1][c]?.kind===k && state.board[r-2][c]?.kind===k));
      const t=state.board[r][c]; t.kind=k; t.type=Type.NORMAL; refreshGem(t);
    }
  }
}

/* =========================
   ПОИСК СОВПАДЕНИЙ
========================= */
function findMatches(b=state.board){
  const mark=new Set(); const groups=[];
  // горизонтальные
  for(let r=0;r<BOARD_ROWS;r++){
    let run=1;
    for(let c=1;c<=BOARD_COLS;c++){
      const a=b[r][c-1], x=(c<BOARD_COLS)?b[r][c]:null;
      const same = x && a && a.type!==Type.COLOR && x.type!==Type.COLOR && a.kind===x.kind;
      if(same) run++; else { if(run>=3){ for(let k=c-run;k<c;k++) mark.add(`${r},${k}`); groups.push({cells:Array.from({length:run},(_,i)=>({r,c:c-run+i})), dir:'h'}); } run=1; }
    }
  }
  // вертикальные
  for(let c=0;c<BOARD_COLS;c++){
    let run=1;
    for(let r=1;r<=BOARD_ROWS;r++){
      const a=b[r-1]?.[c], x=(r<BOARD_ROWS)?b[r][c]:null;
      const same = x && a && a.type!==Type.COLOR && x.type!==Type.COLOR && a.kind===x.kind;
      if(same) run++; else { if(run>=3){ for(let k=r-run;k<r;k++) mark.add(`${k},${c}`); groups.push({cells:Array.from({length:run},(_,i)=>({r:r-run+i,c})), dir:'v'}); } run=1; }
    }
  }
  // склеиваем пересечения для T/L
  const merged=[]; const used=new Set();
  for(let i=0;i<groups.length;i++){
    if(used.has(i)) continue;
    let set = new Set(groups[i].cells.map(p=>`${p.r},${p.c}`));
    let dirs= new Set([groups[i].dir]);
    for(let j=i+1;j<groups.length;j++){
      if(used.has(j)) continue;
      const g2=groups[j];
      if(g2.cells.some(p=>set.has(`${p.r},${p.c}`))){
        g2.cells.forEach(p=>set.add(`${p.r},${p.c}`));
        dirs.add(g2.dir); used.add(j);
      }
    }
    merged.push({cells:[...set].map(s=>{const [r,c]=s.split(',').map(Number); return {r,c};}), dirs});
  }
  return merged;
}

/* =========================
   ВОЗМОЖНЫЕ ХОДЫ / ПОДСКАЗКА
========================= */
function swapCreatesMatch(a,b){
  const cp = state.board.map(row=>row.slice());
  const tA=cp[a.r][a.c], tB=cp[b.r][b.c]; cp[a.r][a.c]=tB; cp[b.r][b.c]=tA;
  return findMatches(cp).length>0;
}
function findAnyMove(){
  for(let r=0;r<BOARD_ROWS;r++) for(let c=0;c<BOARD_COLS;c++){
    const a={r,c};
    for(const b of [{r,c:c+1},{r:r+1,c}]) if(inB(b.r,b.c) && swapCreatesMatch(a,b)) return [a,b];
  }
  return null;
}
function scheduleHint(){
  clearHint();
  state.hintTimer=setTimeout(()=>{
    const mv=findAnyMove();
    if(mv){ state.hintPair=mv;
      const [a,b]=mv; state.board[a.r][a.c]?.el.classList.add('hint'); state.board[b.r][b.c]?.el.classList.add('hint'); }
  }, HINT_DELAY_MS);
}
function clearHint(){
  if(state.hintTimer){ clearTimeout(state.hintTimer); state.hintTimer=null; }
  if(state.hintPair){ const [a,b]=state.hintPair; state.board[a.r][a.c]?.el.classList.remove('hint'); state.board[b.r][b.c]?.el.classList.remove('hint'); state.hintPair=null; }
}

/* =========================
   ГРАВИТАЦИЯ/РЕФИЛЛ
========================= */
async function gravityRefill(){
  let moved=false;
  for(let c=0;c<BOARD_COLS;c++){
    let p=BOARD_ROWS-1;
    for(let r=BOARD_ROWS-1;r>=0;r--){
      const t=state.board[r][c];
      if(t){ if(r!==p){ state.board[p][c]=t; t.r=p; place(t); state.board[r][c]=null; moved=true; } p--; }
    }
    for(let r=p;r>=0;r--){
      const t=createTile(randKind()); state.board[r][c]=t; mountTile(t,r,c);
      t.el.style.transform=`translate(${t.x}px, ${t.y - (p+1-r+1)*TILE_SIZE}px)`; // появление сверху
      await next2frames(); place(t); moved=true;
    }
  }
  if(moved) await wait(TRANSITION_MS+10);
}

/* =========================
   БОНУСЫ / ОЧКИ
========================= */
function scoreForGroups(groups,cascade){ let s=0; for(const g of groups){ const n=g.cells.length; if(n>=3) s += SCORE_BASE3 + (n-3)*SCORE_EXTRA; } return s*(1+cascade); }

function planPowerups(groups, swapInfo){
  const toRemove=new Set(); const create=[];
  for(const g of groups){ g.cells.forEach(p=>toRemove.add(`${p.r},${p.c}`));
    const size=g.cells.length;
    const rc=new Map(), cc=new Map(); g.cells.forEach(p=>{rc.set(p.r,(rc.get(p.r)||0)+1); cc.set(p.c,(cc.get(p.c)||0)+1);});
    const isT = Array.from(rc.values()).some(v=>v>=3) && Array.from(cc.values()).some(v=>v>=3);
    let target = g.cells[ (g.cells.length/2)|0 ];
    if(swapInfo){ for(const cand of [swapInfo.a, swapInfo.b]) if(g.cells.some(p=>p.r===cand.r && p.c===cand.c)){ target=cand; break; } }
    const sample = state.board[target.r][target.c];
    if(isT){ create.push({r:target.r,c:target.c,type:Type.BOMB_3,kind:sample.kind}); }
    else if(size>=5){ create.push({r:target.r,c:target.c,type:Type.COLOR,kind:sample.kind}); }
    else if(size===4){
      const dir = g.dirs.has('h') && !g.dirs.has('v') ? 'h' : (g.dirs.has('v') && !g.dirs.has('h') ? 'v' : 'h');
      create.push({r:target.r,c:target.c,type: dir==='h'?Type.STRIPED_H:Type.STRIPED_V, kind:sample.kind});
    }
  }
  return {toRemove, create};
}
function clearSet(set){ const cleared=[]; set.forEach(k=>{ const [r,c]=k.split(',').map(Number); const t=state.board[r][c]; if(t && !t.removing){ removeTile(t); state.board[r][c]=null; cleared.push({r,c,t}); }}); return cleared; }
function stripEffect(t){ const s=new Set(); if(t.type===Type.STRIPED_H){ for(let c=0;c<BOARD_COLS;c++) s.add(`${t.r},${c}`); } else { for(let r=0;r<BOARD_ROWS;r++) s.add(`${r},${t.c}`); } return s; }
function bomb3Effect(t){ const s=new Set(); for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const r=t.r+dr,c=t.c+dc; if(inB(r,c)) s.add(`${r},${c}`);} return s; }
function colorEffect(kind){ const s=new Set(); for(let r=0;r<BOARD_ROWS;r++) for(let c=0;c<BOARD_COLS;c++){ const t=state.board[r][c]; if(t && t.type!==Type.COLOR && t.kind===kind) s.add(`${r},${c}`);} return s; }
function convertAllOfKind(targetType, kind){ const specials=[]; for(let r=0;r<BOARD_ROWS;r++) for(let c=0;c<BOARD_COLS;c++){ const t=state.board[r][c]; if(t && t.type!==Type.COLOR && t.kind===kind){ t.type=targetType; refreshGem(t); specials.push(t); } } const set=new Set(); for(const t of specials){ const fx = (t.type===Type.BOMB_3)? bomb3Effect(t) : stripEffect(t); fx.forEach(k=>set.add(k)); } return set; }

/* =========================
   ВВОД: ТАЧ-СВАЙП (Pointer Events) + КЛИК + КЛАВИАТУРА
========================= */
function attachTileInput(g,t){
  // Pointer Events обеспечивают единый ввод для iOS тача и мыши
  g.addEventListener('pointerdown', onPointerDown, {passive:false});
  g.addEventListener('click', (e)=>{ if(state.inputLocked||state.paused) return; ensureAudio(); selectOrSwap(t); scheduleHint(); });
  function onPointerDown(e){
    if(state.inputLocked||state.paused) return;
    ensureAudio();
    // Захватываем указатель, чтобы получать move/up даже при выходе
    g.setPointerCapture?.(e.pointerId);
    e.preventDefault();
    state.drag.id = e.pointerId;
    state.drag.startRC = {r:t.r, c:t.c};
    state.drag.startX = e.clientX; state.drag.startY = e.clientY;
    state.drag.didSwap = false;
    window.addEventListener('pointermove', onPointerMove, {passive:false});
    window.addEventListener('pointerup', onPointerUp, {passive:false, once:true});
    window.addEventListener('pointercancel', onPointerUp, {passive:false, once:true});
    clearHint();
  }
  function onPointerMove(e){
    if(e.pointerId!==state.drag.id || state.inputLocked) return;
    const dx = e.clientX - state.drag.startX;
    const dy = e.clientY - state.drag.startY;
    const TH = 18; // порог — комфортно для тача
    if(!state.drag.didSwap && (Math.abs(dx)>TH || Math.abs(dy)>TH)){
      const primary = Math.abs(dx) >= Math.abs(dy) ? (dx>0?{dr:0,dc:1}:{dr:0,dc:-1}) : (dy>0?{dr:1,dc:0}:{dr:-1,dc:0});
      const a = state.drag.startRC;
      const b = {r:a.r+primary.dr, c:a.c+primary.dc};
      if(inB(b.r,b.c)){
        state.drag.didSwap = true;
        performSwap(a,b).then(()=>{
          // после свопа можно заново показывать подсказку
          scheduleHint();
        });
      }
    }
  }
  function onPointerUp(e){
    window.removeEventListener('pointermove', onPointerMove, {passive:false});
    if(!state.drag.didSwap && state.drag.startRC){ // это был тап
      selectOrSwap(t);
      scheduleHint();
    }
    state.drag.id=null; state.drag.startRC=null; state.drag.didSwap=false;
  }
}

function setSelected(t){
  document.querySelectorAll('.tile.selected').forEach(n=>n.classList.remove('selected'));
  state.selected = t ? {r:t.r, c:t.c} : null;
  if(t) t.el.classList.add('selected');
}
async function badSwapFX(a,b){
  sfx.bad();
  a.el.classList.add('shake'); b.el.classList.add('shake');
  await wait(250);
  a.el.classList.remove('shake'); b.el.classList.remove('shake');
}
async function selectOrSwap(t){
  if(!state.selected){ setSelected(t); sfx.click(); return; }
  const a=state.selected, b={r:t.r,c:t.c};
  if(a.r===b.r && a.c===b.c){ setSelected(null); return; }
  if(Math.abs(a.r-b.r)+Math.abs(a.c-b.c)!==1){ setSelected(t); return; } // не соседи → пере-выбор
  setSelected(null);
  await performSwap(a,b);
}

async function performSwap(a,b){
  const A=state.board[a.r][a.c], B=state.board[b.r][b.c];
  if(!A||!B) return false;
  state.inputLocked=true; sfx.swap();
  // визуально
  const ax=A.x, ay=A.y, bx=B.x, by=B.y;
  A.el.style.transform=`translate(${bx}px, ${by}px)`;
  B.el.style.transform=`translate(${ax}px, ${ay}px)`;
  await wait(TRANSITION_MS);
  // логически
  state.board[a.r][a.c]=B; B.r=a.r; B.c=a.c; place(B);
  state.board[b.r][b.c]=A; A.r=b.r; A.c=b.c; place(A);

  // спец-комбо без матча
  const combo = await trySpecialCombo(A,B);
  if(combo){ state.inputLocked=false; return true; }

  const matches=findMatches();
  if(!matches.length){
    // откат
    await wait(10);
    state.board[a.r][a.c]=A; A.r=a.r; A.c=a.c; place(A);
    state.board[b.r][b.c]=B; B.r=b.r; B.c=b.c; place(B);
    await wait(TRANSITION_MS);
    await badSwapFX(A,B);
    state.inputLocked=false;
    return false;
  }else{
    await resolveMatchesLoop(matches,{a,b});
    state.inputLocked=false;
    return true;
  }
}

async function trySpecialCombo(A,B){
  const aSpec=A.type!==Type.NORMAL, bSpec=B.type!==Type.NORMAL;
  // color + color
