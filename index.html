<!--
ИНСТРУКЦИЯ ПО НАСТРОЙКЕ:
- Размер поля: измените BOARD_ROWS и BOARD_COLS (по умолчанию 8x8).
- Размер плитки (в пикселях): измените TILE_SIZE (по умолчанию 64).
- Количество типов фишек: измените TILE_TYPES (по умолчанию 6).
- Цели режимов: измените TARGET_SCORE для режима по ходам, MOVES_COUNT — количество ходов.
- Режим по времени: измените TIMED_SECONDS — длительность в секундах.
Все константы находятся в секции "КОНСТАНТЫ" внизу этого комментария.
Лицензия: весь код и встроенные ассеты — CC0/MIT.
-->
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>3 в ряд</title>
<meta name="color-scheme" content="light dark">
<style>
  :root{
    --bg: #ffffff;
    --fg: #111111;
    --muted:#666;
    --panel:#f2f2f2;
    --accent:#0072B2;
    --good:#009E73;
    --warn:#D55E00;
    --tile1:#E69F00;
    --tile2:#56B4E9;
    --tile3:#009E73;
    --tile4:#F0E442;
    --tile5:#0072B2;
    --tile6:#D55E00;
    --board-shadow: 0 8px 24px rgba(0,0,0,.12);
    --focus: 2px solid #0072B2;
    --ring: 0 0 0 3px rgba(0,114,178,.35);
    --transition: 200ms;
  }
  @media (prefers-color-scheme: dark){
    :root{
      --bg:#0f1115;
      --fg:#f5f7fb;
      --muted:#a3a7b3;
      --panel:#171a21;
      --board-shadow: 0 8px 24px rgba(0,0,0,.5);
    }
  }
  html[data-theme="light"]{
    color-scheme: light;
    --bg:#ffffff; --fg:#111; --muted:#666; --panel:#f2f2f2; --board-shadow:0 8px 24px rgba(0,0,0,.12);
  }
  html[data-theme="dark"]{
    color-scheme: dark;
    --bg:#0f1115; --fg:#f5f7fb; --muted:#a3a7b3; --panel:#171a21; --board-shadow:0 8px 24px rgba(0,0,0,.5);
  }
  *{box-sizing:border-box}
  body{
    margin:0; background:var(--bg); color:var(--fg); font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Ubuntu, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    display:flex; min-height:100dvh; flex-direction:column; align-items:center; justify-content:flex-start; gap:12px;
  }
  header{
    width:100%; max-width:1024px; padding:12px clamp(8px,4vw,24px); display:flex; align-items:center; justify-content:space-between; gap:12px; background:var(--panel); position:sticky; top:0; z-index:10;
    box-shadow: 0 2px 8px rgba(0,0,0,.08);
  }
  .top-left, .top-right{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
  .stat{background: transparent; padding:6px 10px; border-radius:10px; display:flex; gap:8px; align-items:center; white-space:nowrap}
  .stat b{font-size:1rem}
  .btn{
    border:1px solid rgba(127,127,127,.25);
    background:var(--bg);
    color:var(--fg);
    padding:8px 12px; border-radius:12px; cursor:pointer; transition:transform .06s ease, background .2s, border-color .2s;
    box-shadow: 0 1px 0 rgba(255,255,255,.05) inset;
    user-select:none;
  }
  .btn:active{transform:translateY(1px) scale(.98)}
  .btn.primary{border-color:transparent; background:var(--accent); color:#fff}
  .btn.ghost{background:transparent}
  .btn.toggle[aria-pressed="true"]{background:var(--accent); color:#fff}
  .wrap{
    width:100%; max-width:1024px; display:grid; place-items:center; padding: 8px clamp(8px,4vw,24px) 24px;
  }
  .board-shell{
    width:min(96vw, calc(var(--tile)*var(--cols) + 24px));
    aspect-ratio: 1 / 1; background:var(--panel);
    border-radius:24px; padding:12px; box-shadow: var(--board-shadow); position:relative; overflow:hidden;
    display:grid; place-items:center;
  }
  /* Board will scale responsively; base tile size is controlled by CSS var --tile */
  .board{
    width: calc(var(--tile) * var(--cols));
    height: calc(var(--tile) * var(--rows));
    touch-action: manipulation;
  }
  /* SVG tile groups animate via transform */
  .tile{ transition: transform var(--transition) ease, opacity var(--transition) ease; will-change: transform, opacity; cursor:pointer; }
  .tile:focus{ outline: none; }
  .tile[tabindex]:focus-visible .focus-ring{opacity:1}
  .focus-ring{ pointer-events:none; opacity:0; transition:opacity .12s ease }
  .selected .focus-ring{opacity:1}
  /* Hint pulse */
  @keyframes pulse {
    0%{filter: drop-shadow(0 0 0 rgba(0,114,178,0))}
    50%{filter: drop-shadow(0 0 8px rgba(0,114,178,.8))}
    100%{filter: drop-shadow(0 0 0 rgba(0,114,178,0))}
  }
  .hint{ animation: pulse 1.5s ease-in-out infinite; }
  /* Bad swap shake */
  .shake{ animation: shake .25s ease }
  @keyframes shake{
    0%{ transform: translate(var(--x), var(--y)) }
    25%{ transform: translate(calc(var(--x) + 6px), var(--y)) }
    50%{ transform: translate(calc(var(--x) - 6px), var(--y)) }
    75%{ transform: translate(calc(var(--x) + 4px), var(--y)) }
    100%{ transform: translate(var(--x), var(--y)) }
  }
  /* Overlays */
  .overlay{
    position:absolute; inset:0; background: rgba(0,0,0,.5);
    display:none; place-items:center; z-index:20;
  }
  .overlay.show{ display:grid }
  .card{
    background:var(--bg); color:var(--fg); padding:16px; border-radius:16px; width:min(92vw, 520px); box-shadow: var(--board-shadow);
  }
  .card h2{margin:0 0 8px}
  .card p{margin:6px 0}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .settings-grid{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; }
  .switch{ display:inline-flex; align-items:center; gap:8px }
  .switch input{ width:40px; height:22px; appearance:none; background:#bbb; border-radius:999px; position:relative; outline:none; cursor:pointer; transition:background .2s }
  .switch input:checked{ background:var(--accent) }
  .switch input::after{ content:""; position:absolute; top:3px; left:3px; width:16px; height:16px; background:#fff; border-radius:50%; transition: transform .2s }
  .switch input:checked::after{ transform: translateX(18px) }
  .sr-only{ position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }
  footer{color:var(--muted); padding:8px 16px 24px}
  /* Responsive tile size clamp */
  :root{ --tile:64px; --rows:8; --cols:8 }
  @media (max-width: 480px){
    :root{ --tile: min(64px, calc((100vw - 48px)/var(--cols))) }
  }
</style>
</head>
<body>
  <header aria-label="Панель управления">
    <div class="top-left">
      <div class="stat" id="scoreStat" aria-live="polite"><span>Счёт:</span> <b id="score">0</b></div>
      <div class="stat" id="goalStat"><span id="goalLabel">Цель:</span> <b id="goal">500</b></div>
      <div class="stat" id="movesStat"><span>Ходов:</span> <b id="moves">30</b></div>
      <div class="stat" id="timeStat" style="display:none"><span>Время:</span> <b id="time">02:00</b></div>
      <div class="stat"><span>Лучший:</span> <b id="best">0</b></div>
    </div>
    <div class="top-right">
      <button class="btn primary" id="newGameBtn">Новая игра</button>
      <button class="btn" id="pauseBtn" aria-pressed="false">Пауза</button>
      <button class="btn" id="settingsBtn">Настройки</button>
      <button class="btn toggle" id="soundBtn" aria-pressed="true">Звук: Вкл</button>
    </div>
  </header>

  <div class="wrap">
    <div class="board-shell" id="boardShell">
      <svg id="board" class="board" role="grid" aria-label="Игровое поле 8 на 8" tabindex="0"></svg>

      <div class="overlay" id="pauseOverlay" role="dialog" aria-modal="true" aria-labelledby="pauseTitle">
        <div class="card">
          <h2 id="pauseTitle">Пауза</h2>
          <div class="row" style="justify-content:flex-end">
            <button class="btn" id="resumeBtn">Продолжить</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="onboarding" role="dialog" aria-modal="true" aria-labelledby="onbTitle">
        <div class="card">
          <h2 id="onbTitle">Как играть</h2>
          <p>Меняйте местами соседние фишки, чтобы собрать 3+ одного цвета по горизонтали или вертикали.</p>
          <p>Комбинации: 4 — полосатая (очищает линию), 5 — бомба цвета, Т/Г — бомба 3×3. Комбинации бонусов работают.</p>
          <p>Управление: мышь/тач — выбрать и поменять; клавиатура — стрелки, Enter/Пробел — выбрать, Esc — снять.</p>
          <p>Цель в режиме по ходам — набрать нужный счёт за отведённое число ходов. В режиме по времени — за отведённое время.</p>
          <div class="row" style="justify-content:flex-end; gap:8px">
            <label class="switch">
              <input type="checkbox" id="dontShowHelp">
              <span>Больше не показывать</span>
            </label>
            <button class="btn" id="helpOk">Понятно</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="settings" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
        <div class="card">
          <h2 id="settingsTitle">Настройки</h2>
          <div class="settings-grid" style="margin-top:8px">
            <div>Режим игры</div>
            <div>
              <select id="modeSelect" aria-label="Режим">
                <option value="moves">По ходам</option>
                <option value="timed">По времени</option>
              </select>
            </div>
            <div>Тема</div>
            <div>
              <select id="themeSelect" aria-label="Тема">
                <option value="system">Системная</option>
                <option value="light">Светлая</option>
                <option value="dark">Тёмная</option>
              </select>
            </div>
            <div>Звук</div>
            <div class="switch">
              <input type="checkbox" id="soundToggle" checked>
            </div>
          </div>
          <div class="row" style="justify-content:flex-end; margin-top:12px">
            <button class="btn" id="settingsClose">Понятно</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="gameOver" role="dialog" aria-modal="true" aria-labelledby="overTitle">
        <div class="card">
          <h2 id="overTitle">Итог</h2>
          <p id="overText">Победа!</p>
          <div class="row" style="justify-content:flex-end">
            <button class="btn primary" id="overNew">Новая игра</button>
          </div>
        </div>
      </div>

    </div>
  </div>
  <footer aria-hidden="true">© CC0/MIT. Работает офлайн в одном файле. Поддерживает светлую/тёмную темы.</footer>

<script>
/* =========================
   КОНСТАНТЫ
========================= */
const BOARD_ROWS = 8;
const BOARD_COLS = 8;
const TILE_SIZE = 64;
const TILE_TYPES = 6; // количество базовых цветов
const TARGET_SCORE = 500;
const MOVES_COUNT = 30;
const TIMED_SECONDS = 120;
const HINT_DELAY_MS = 5000;
const TRANSITION_MS = 200; // 150–250 мс
const SCORE_BASE3 = 10;
const SCORE_EXTRA = 5; // за каждую сверх 3
const SCORE_POWERUP_ACT = 50;

/* =========================
   СОСТОЯНИЕ
========================= */
let state = {
  mode: 'moves', // 'moves' | 'timed'
  score: 0,
  best: 0,
  target: TARGET_SCORE,
  movesLeft: MOVES_COUNT,
  timeLeft: TIMED_SECONDS,
  paused: false,
  inputLocked: false,
  selected: null, // {r,c}
  hover: null,
  board: [], // 2D array of tiles
  tilesById: new Map(), // id -> tile object
  idCounter: 1,
  cascade: 0,
  hintTimer: null,
  hintPair: null,
  soundOn: true,
  theme: 'system',
  rngSeed: Date.now() & 0x7fffffff
};

const Type = {
  NORMAL: 'normal',
  STRIPED_H: 'stripedH',
  STRIPED_V: 'stripedV',
  BOMB_3: 'bomb3',
  COLOR: 'color'
};

const palette = [
  getComputedStyle(document.documentElement).getPropertyValue('--tile1').trim() || '#E69F00',
  getComputedStyle(document.documentElement).getPropertyValue('--tile2').trim() || '#56B4E9',
  getComputedStyle(document.documentElement).getPropertyValue('--tile3').trim() || '#009E73',
  getComputedStyle(document.documentElement).getPropertyValue('--tile4').trim() || '#F0E442',
  getComputedStyle(document.documentElement).getPropertyValue('--tile5').trim() || '#0072B2',
  getComputedStyle(document.documentElement).getPropertyValue('--tile6').trim() || '#D55E00',
];

/* =========================
   УТИЛИТЫ
========================= */
function rng() {
  // LCG для детерминированности при регенерации
  state.rngSeed = (1103515245 * state.rngSeed + 12345) & 0x7fffffff;
  return state.rngSeed / 0x80000000;
}
function randInt(n){ return Math.floor(rng() * n); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function inBounds(r,c){ return r>=0 && c>=0 && r<BOARD_ROWS && c<BOARD_COLS; }
function areNeighbors(a,b){ return a && b && ((Math.abs(a.r-b.r)===1 && a.c===b.c) || (Math.abs(a.c-b.c)===1 && a.r===b.r)); }
function tileColor(kind){ return palette[kind % TILE_TYPES]; }
function tileAriaLabel(t){
  let label = 'фишка ' + (t.kind+1);
  if(t.type===Type.STRIPED_H) label += ', полосатая (гор.)';
  if(t.type===Type.STRIPED_V) label += ', полосатая (верт.)';
  if(t.type===Type.BOMB_3) label += ', бомба 3 на 3';
  if(t.type===Type.COLOR) label += ', бомба цвета';
  return label;
}
function wait(ms){ return new Promise(res => setTimeout(res, ms)); }
function nextFrame(){ return new Promise(res => requestAnimationFrame(()=>requestAnimationFrame(res))); }
function timeFormat(s){ s = Math.max(0, s|0); const m = (s/60|0).toString().padStart(2,'0'); const ss=(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; }
function setStatus(){ document.getElementById('score').textContent = state.score; document.getElementById('moves').textContent = state.movesLeft; document.getElementById('time').textContent = timeFormat(state.timeLeft); document.getElementById('best').textContent = state.best; }
function setCSSVars(){
  document.documentElement.style.setProperty('--rows', BOARD_ROWS);
  document.documentElement.style.setProperty('--cols', BOARD_COLS);
  document.documentElement.style.setProperty('--tile', TILE_SIZE+'px');
}
function saveLocal(){
  localStorage.setItem('m3_best', String(state.best));
  localStorage.setItem('m3_mode', state.mode);
  localStorage.setItem('m3_theme', state.theme);
  localStorage.setItem('m3_sound', state.soundOn ? 'on':'off');
}
function loadLocal(){
  state.best = parseInt(localStorage.getItem('m3_best')||'0',10);
  state.mode = localStorage.getItem('m3_mode')||'moves';
  state.theme = localStorage.getItem('m3_theme')||'system';
  state.soundOn = (localStorage.getItem('m3_sound')||'on')==='on';
}
function applyTheme(){
  if(state.theme==='system'){ document.documentElement.removeAttribute('data-theme'); }
  else document.documentElement.setAttribute('data-theme', state.theme);
}
function announce(text){
  // lightweight aria-live using scoreStat
  const el = document.getElementById('scoreStat');
  el.setAttribute('aria-label', text);
}

/* =========================
   ЗВУК (WebAudio)
========================= */
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx){ try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ audioCtx = null; } }
}
function beep({freq=440, dur=0.08, type='sine', gain=0.03}={}){
  if(!state.soundOn || !audioCtx) return;
  const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type; osc.frequency.value = freq;
  g.gain.setValueAtTime(0, t);
  g.gain.linearRampToValueAtTime(gain, t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
  osc.connect(g).connect(audioCtx.destination);
  osc.start(t);
  osc.stop(t + dur + 0.02);
}
const sounds = {
  click: ()=>beep({freq:260,type:'triangle',dur:0.06}),
  swap: ()=>beep({freq:310,type:'sawtooth',dur:0.07}),
  bad: ()=>{ beep({freq:180,type:'square',dur:0.08}); setTimeout(()=>beep({freq:120,type:'square',dur:0.08}),60); },
  match: (lvl=0)=>beep({freq: 420+lvl*40, type:'triangle', dur:0.08}),
  cascade: (n=1)=>beep({freq: 520+(n*60), type:'sine', dur:0.1, gain:0.04}),
  button: ()=>beep({freq:540,type:'triangle',dur:0.05})
};

/* =========================
   РЕНДЕР И DOM
========================= */
const svgNS = 'http://www.w3.org/2000/svg';
const boardSVG = document.getElementById('board');

function createTile(kind, type=Type.NORMAL){
  const id = state.idCounter++;
  const tile = { id, kind, type, r:-1, c:-1, el:null, x:0, y:0, removing:false };
  state.tilesById.set(id, tile);
  return tile;
}
function mountTile(tile, r, c){
  tile.r = r; tile.c = c; tile.x = c*TILE_SIZE; tile.y = r*TILE_SIZE;
  const g = document.createElementNS(svgNS, 'g');
  g.classList.add('tile');
  g.setAttribute('data-id', tile.id);
  g.setAttribute('role','gridcell');
  g.setAttribute('tabindex','0');
  g.setAttribute('aria-label', tileAriaLabel(tile));
  const bg = document.createElementNS(svgNS,'rect');
  bg.setAttribute('x', 4); bg.setAttribute('y',4);
  bg.setAttribute('rx', 14); bg.setAttribute('ry',14);
  bg.setAttribute('width', TILE_SIZE-8);
  bg.setAttribute('height', TILE_SIZE-8);
  bg.setAttribute('fill', '#0000'); // transparent
  const gem = drawGem(tile);
  const ring = document.createElementNS(svgNS,'rect');
  ring.setAttribute('class','focus-ring');
  ring.setAttribute('x',2); ring.setAttribute('y',2);
  ring.setAttribute('rx', 16); ring.setAttribute('ry',16);
  ring.setAttribute('width', TILE_SIZE-4);
  ring.setAttribute('height', TILE_SIZE-4);
  ring.setAttribute('stroke','#0072B2'); ring.setAttribute('stroke-width','3');
  ring.setAttribute('fill','none');
  g.append(bg, gem, ring);
  boardSVG.appendChild(g);
  tile.el = g;
  positionTile(tile);
  attachTileEvents(g, tile);
}

function drawGem(tile){
  // return a group for gem, based on tile.type
  const g = document.createElementNS(svgNS,'g');
  const color = tile.type===Type.COLOR ? '#333' : tileColor(tile.kind);
  // base circle
  const circle = document.createElementNS(svgNS, 'circle');
  circle.setAttribute('cx', TILE_SIZE/2);
  circle.setAttribute('cy', TILE_SIZE/2);
  circle.setAttribute('r', TILE_SIZE*0.28);
  circle.setAttribute('fill', color);
  circle.setAttribute('stroke', '#0005');
  circle.setAttribute('stroke-width', 2);
  g.appendChild(circle);

  if(tile.type===Type.STRIPED_H || tile.type===Type.STRIPED_V){
    // stripes overlay
    for(let i=-2;i<=2;i++){
      const line = document.createElementNS(svgNS,'rect');
      if(tile.type===Type.STRIPED_H){
        line.setAttribute('x', TILE_SIZE*0.2*(i+3)-6);
        line.setAttribute('y', TILE_SIZE*0.28-6);
        line.setAttribute('width', 12);
        line.setAttribute('height', 12);
        line.setAttribute('transform', `rotate(45 ${TILE_SIZE/2} ${TILE_SIZE/2})`);
      }else{
        line.setAttribute('x', TILE_SIZE*0.28-6);
        line.setAttribute('y', TILE_SIZE*0.2*(i+3)-6);
        line.setAttribute('width', 12);
        line.setAttribute('height', 12);
        line.setAttribute('transform', `rotate(45 ${TILE_SIZE/2} ${TILE_SIZE/2})`);
      }
      line.setAttribute('fill','#fff');
      line.setAttribute('opacity','0.7');
      g.appendChild(line);
    }
  }
  if(tile.type===Type.BOMB_3){
    const sq = document.createElementNS(svgNS,'rect');
    sq.setAttribute('x', TILE_SIZE/2 - TILE_SIZE*0.18);
    sq.setAttribute('y', TILE_SIZE/2 - TILE_SIZE*0.18);
    sq.setAttribute('width', TILE_SIZE*0.36);
    sq.setAttribute('height', TILE_SIZE*0.36);
    sq.setAttribute('rx', 6);
    sq.setAttribute('fill', '#fff');
    sq.setAttribute('opacity','0.85');
    g.appendChild(sq);
  }
  if(tile.type===Type.COLOR){
    // sparkles
    for(let i=0;i<6;i++){
      const star = document.createElementNS(svgNS,'circle');
      const angle = i * Math.PI*2/6;
      star.setAttribute('cx', TILE_SIZE/2 + Math.cos(angle)*TILE_SIZE*0.18);
      star.setAttribute('cy', TILE_SIZE/2 + Math.sin(angle)*TILE_SIZE*0.18);
      star.setAttribute('r', 3);
      star.setAttribute('fill', '#fff');
      g.appendChild(star);
    }
  }
  return g;
}

function refreshGem(tile){
  if(!tile.el) return;
  const old = tile.el.children[1]; // gem group
  tile.el.removeChild(old);
  tile.el.insertBefore(drawGem(tile), tile.el.children[1]);
  tile.el.setAttribute('aria-label', tileAriaLabel(tile));
}

function positionTile(tile){
  const x = tile.c * TILE_SIZE;
  const y = tile.r * TILE_SIZE;
  tile.x = x; tile.y = y;
  tile.el.style.setProperty('--x', x+'px');
  tile.el.style.setProperty('--y', y+'px');
  tile.el.style.transform = `translate(${x}px, ${y}px)`;
}

function removeTile(tile){
  tile.removing = true;
  tile.el.style.opacity = '0';
  setTimeout(()=>{ if(tile.el && tile.el.parentNode===boardSVG) boardSVG.removeChild(tile.el); tile.el=null; }, TRANSITION_MS);
}

/* =========================
   ГЕНЕРАТОР ПОЛЯ
========================= */
function emptyBoard(){
  state.board = Array.from({length:BOARD_ROWS},()=>Array(BOARD_COLS).fill(null));
}
function randomKind(){ return randInt(TILE_TYPES); }

function generateBoard(){
  emptyBoard();
  // fill without starting matches
  for(let r=0;r<BOARD_ROWS;r++){
    for(let c=0;c<BOARD_COLS;c++){
      let kind, attempts=0;
      do{
        kind = randomKind(); attempts++;
      }while((c>=2 && state.board[r][c-1]?.kind===kind && state.board[r][c-2]?.kind===kind)
          || (r>=2 && state.board[r-1][c]?.kind===kind && state.board[r-2][c]?.kind===kind));
      const t = createTile(kind);
      state.board[r][c] = t;
      mountTile(t, r, c);
    }
  }
  // ensure at least one move
  let safety=0;
  while(!findAnyPossibleMove() && safety<50){
    reshuffleBoard();
    safety++;
  }
}

function reshuffleBoard(){
  // simple reshuffle: reassign kinds randomly, ensure no matches
  for(let r=0;r<BOARD_ROWS;r++){
    for(let c=0;c<BOARD_COLS;c++){
      let kind, attempts=0;
      do{
        kind = randomKind(); attempts++;
      }while((c>=2 && state.board[r][c-1]?.kind===kind && state.board[r][c-2]?.kind===kind)
          || (r>=2 && state.board[r-1][c]?.kind===kind && state.board[r-2][c]?.kind===kind));
      const t = state.board[r][c];
      t.kind = kind; t.type = Type.NORMAL;
      refreshGem(t);
    }
  }
}

/* =========================
   ПОИСК СОВПАДЕНИЙ
========================= */
function findMatches(board=state.board){
  const matched = new Set(); // store "r,c"
  // horizontal
  for(let r=0;r<BOARD_ROWS;r++){
    let run=1;
    for(let c=1;c<=BOARD_COLS;c++){
      const curr = c<BOARD_COLS ? board[r][c] : null;
      const prev = board[r][c-1];
      const same = curr && prev && prev.type!==Type.COLOR && curr.type!==Type.COLOR && curr.kind===prev.kind;
      if(same){ run++; }
      else{
        if(run>=3){
          for(let k=c-run;k<c;k++){ matched.add(`${r},${k}`); }
        }
        run=1;
      }
    }
  }
  // vertical
  for(let c=0;c<BOARD_COLS;c++){
    let run=1;
    for(let r=1;r<=BOARD_ROWS;r++){
      const curr = r<BOARD_ROWS ? board[r][c] : null;
      const prev = board[r-1]?.[c];
      const same = curr && prev && prev.type!==Type.COLOR && curr.type!==Type.COLOR && curr.kind===prev.kind;
      if(same){ run++; }
      else{
        if(run>=3){
          for(let k=r-run;k<r;k++){ matched.add(`${k},${c}`); }
        }
        run=1;
      }
    }
  }
  // detect shapes and plan powerups
  const groups = []; // each: {cells:[{r,c}], dir:'h'|'v'|null}
  // Build groups from matched set by expanding runs
  // Horizontal groups
  for(let r=0;r<BOARD_ROWS;r++){
    let c=0;
    while(c<BOARD_COLS){
      if(matched.has(`${r},${c}`)){
        let k=c;
        const cells=[];
        while(k<BOARD_COLS && matched.has(`${r},${k}`)){ cells.push({r,c:k}); k++; }
        if(cells.length>=3) groups.push({cells, dir:'h'});
        c=k;
      }else c++;
    }
  }
  // Vertical groups
  for(let c=0;c<BOARD_COLS;c++){
    let r=0;
    while(r<BOARD_ROWS){
      if(matched.has(`${r},${c}`)){
        let k=r;
        const cells=[];
        while(k<BOARD_ROWS && matched.has(`${k},${c}`)){ cells.push({r:k,c}); k++; }
        if(cells.length>=3) groups.push({cells, dir:'v'});
        r=k;
      }else r++;
    }
  }
  // Merge overlapping into combined groups
  const combined = [];
  const used = new Set();
  for(let i=0;i<groups.length;i++){
    if(used.has(i)) continue;
    let set = new Set(groups[i].cells.map(p=>`${p.r},${p.c}`));
    let dirs = new Set([groups[i].dir]);
    for(let j=i+1;j<groups.length;j++){
      if(used.has(j)) continue;
      const g2 = groups[j];
      const overlap = g2.cells.some(p=>set.has(`${p.r},${p.c}`));
      if(overlap){
        g2.cells.forEach(p=>set.add(`${p.r},${p.c}`));
        dirs.add(g2.dir);
        used.add(j);
      }
    }
    combined.push({cells:[...set].map(s=>{const [r,c]=s.split(',').map(Number); return {r,c};}), dirs});
  }
  return combined;
}

/* =========================
   ПОИСК ВОЗМОЖНЫХ ХОДОВ (для подсказки и генерации)
========================= */
function checkSwapCreatesMatch(a,b){
  const board = state.board.map(row=>row.slice());
  // swap references
  const tA = board[a.r][a.c], tB = board[b.r][b.c];
  board[a.r][a.c] = tB; board[b.r][b.c] = tA;
  const matches = findMatches(board);
  return matches.length>0;
}
function findAnyPossibleMove(){
  for(let r=0;r<BOARD_ROWS;r++){
    for(let c=0;c<BOARD_COLS;c++){
      const a = {r,c};
      const neighbors = [{r,c:c+1},{r:r+1,c}];
      for(const b of neighbors){
        if(inBounds(b.r,b.c) && checkSwapCreatesMatch(a,b)) return [a,b];
      }
    }
  }
  return null;
}

/* =========================
   ГРАВИТАЦИЯ / РЕФИЛЛ
========================= */
async function applyGravityAndRefill(){
  let moved = false;
  for(let c=0;c<BOARD_COLS;c++){
    let pointer = BOARD_ROWS-1;
    for(let r=BOARD_ROWS-1;r>=0;r--){
      const t = state.board[r][c];
      if(t){ if(r!==pointer){ state.board[pointer][c]=t; t.r=pointer; positionTile(t); state.board[r][c]=null; moved=true; } pointer--; }
    }
    // Refill new tiles
    for(let r=pointer;r>=0;r--){
      const t = createTile(randomKind());
      state.board[r][c]=t;
      mountTile(t, r, c);
      // spawn from above for fall animation
      t.r = r; t.c = c; t.y = (r - (pointer+1)) * TILE_SIZE - TILE_SIZE; // start above
      t.el.style.transform = `translate(${t.x}px, ${t.y}px)`;
      await nextFrame();
      positionTile(t);
      moved=true;
    }
  }
  if(moved) await wait(TRANSITION_MS+10);
}

/* =========================
   ОЦЕНКА И ПОВЕДЕНИЕ БОНУСОВ
========================= */
function cellsToSet(cells){ const s=new Set(); cells.forEach(p=>s.add(`${p.r},${p.c}`)); return s; }

function planPowerups(groups, swapInfo){
  // Determine special creations based on groups sizes and shapes.
  // Return: {toRemove:Set("r,c"), create:[{r,c,type,kind}]}
  const toRemove = new Set();
  const create = [];

  for(const g of groups){
    g.cells.forEach(p=>toRemove.add(`${p.r},${p.c}`));
    const size = g.cells.length;
    // Determine center/intersection
    const rcnt = new Map(); const ccnt = new Map();
    for(const p of g.cells){ rcnt.set(p.r,(rcnt.get(p.r)||0)+1); ccnt.set(p.c,(ccnt.get(p.c)||0)+1); }
    const isTshape = (Array.from(rcnt.values()).some(v=>v>=3) && Array.from(ccnt.values()).some(v=>v>=3));
    const intersection = g.cells.find(p=> rcnt.get(p.r)>=3 && ccnt.get(p.c)>=3 ) || g.cells[ (g.cells.length/2)|0 ];

    // Decide created special type at swap focus if available
    let targetCell = intersection;
    if(swapInfo){
      // Prefer the cell where the player swapped into the line if it belongs to this group
      const candidates = [swapInfo.a, swapInfo.b];
      for(const cand of candidates){
        if(g.cells.some(p=>p.r===cand.r && p.c===cand.c)){ targetCell = cand; break; }
      }
    }

    const sampleTile = state.board[targetCell.r][targetCell.c];
    if(isTshape){
      create.push({r:targetCell.r, c:targetCell.c, type:Type.BOMB_3, kind: sampleTile.kind});
    }else if(size>=5){
      create.push({r:targetCell.r, c:targetCell.c, type:Type.COLOR, kind: sampleTile.kind});
    }else if(size===4){
      // orientation by dir
      const dir = g.dirs.has('h') && !g.dirs.has('v') ? 'h' : (g.dirs.has('v') && !g.dirs.has('h') ? 'v' : 'h');
      create.push({r:targetCell.r, c:targetCell.c, type: dir==='h'?Type.STRIPED_H:Type.STRIPED_V, kind: sampleTile.kind});
    }
  }
  return {toRemove, create};
}

function collectScoreForGroup(groups, cascadeLevel){
  let gained = 0;
  for(const g of groups){
    const size = g.cells.length;
    if(size>=3){
      gained += SCORE_BASE3 + (size-3)*SCORE_EXTRA;
    }
  }
  const multiplier = 1 + cascadeLevel;
  return Math.max(0, gained * multiplier);
}

function clearCells(set){
  const cleared = [];
  set.forEach(key=>{
    const [r,c]=key.split(',').map(Number);
    const t = state.board[r][c];
    if(t && !t.removing){ removeTile(t); state.board[r][c]=null; cleared.push({r,c,t}); }
  });
  return cleared;
}

function activateStriped(tile){
  const cleared = new Set();
  if(tile.type===Type.STRIPED_H){
    for(let c=0;c<BOARD_COLS;c++) cleared.add(`${tile.r},${c}`);
  }else{ // V
    for(let r=0;r<BOARD_ROWS;r++) cleared.add(`${r},${tile.c}`);
  }
  return cleared;
}

function activateBomb3(tile){
  const cleared = new Set();
  for(let dr=-1; dr<=1; dr++){
    for(let dc=-1; dc<=1; dc++){
      const r=tile.r+dr, c=tile.c+dc;
      if(inBounds(r,c)) cleared.add(`${r},${c}`);
    }
  }
  return cleared;
}

function activateColorBomb(colorKind){
  const cleared = new Set();
  for(let r=0;r<BOARD_ROWS;r++){
    for(let c=0;c<BOARD_COLS;c++){
      const t = state.board[r][c];
      if(t && t.type!==Type.COLOR && t.kind===colorKind) cleared.add(`${r},${c}`);
    }
  }
  return cleared;
}

function activateAllOfKindTo(type, kind){
  // convert all 'kind' into given special and trigger them
  const effects = [];
  for(let r=0;r<BOARD_ROWS;r++){
    for(let c=0;c<BOARD_COLS;c++){
      const t = state.board[r][c];
      if(t && t.type!==Type.COLOR && t.kind===kind){
        t.type = type; refreshGem(t);
        effects.push(t);
      }
    }
  }
  // Trigger effects (chain)
  const cleared = new Set();
  for(const t of effects){
    if(t.type===Type.STRIPED_H || t.type===Type.STRIPED_V){
      const s = activateStriped(t);
      s.forEach(k=>cleared.add(k));
    }else if(t.type===Type.BOMB_3){
      const s = activateBomb3(t);
      s.forEach(k=>cleared.add(k));
    }
  }
  return cleared;
}

/* =========================
   ВВОД / ОБМЕН
========================= */
function attachTileEvents(el, tile){
  const onActivate = (ev)=>{
    if(state.paused || state.inputLocked) return;
    ensureAudio();
    el.focus({preventScroll:true});
    selectOrSwap(tile);
  };
  el.addEventListener('click', onActivate);
  el.addEventListener('touchstart', (e)=>{ e.preventDefault(); onActivate(e); }, {passive:false});
}

function setSelected(tile){
  // remove previous selection
  document.querySelectorAll('.tile.selected').forEach(n=>n.classList.remove('selected'));
  if(tile){
    state.selected = {r:tile.r, c:tile.c};
    tile.el.classList.add('selected');
  }else{
    state.selected = null;
  }
}

async function badSwapAnimation(aTile, bTile){
  sounds.bad();
  // animate towards each other and back using shake keyframes (based on CSS vars --x,--y)
  aTile.el.classList.add('shake');
  bTile.el.classList.add('shake');
  await wait(250);
  aTile.el.classList.remove('shake');
  bTile.el.classList.remove('shake');
}

async function performSwap(a,b, allowNoMatchSpecial=false){
  const A = state.board[a.r][a.c];
  const B = state.board[b.r][b.c];
  if(!A || !B) return false;

  state.inputLocked = true;
  sounds.swap();

  // Visual swap first (update transforms), keep logical until validated
  const ax=A.x, ay=A.y, bx=B.x, by=B.y;
  A.el.style.transform = `translate(${bx}px, ${by}px)`;
  B.el.style.transform = `translate(${ax}px, ${ay}px)`;
  await wait(TRANSITION_MS);

  // Logical swap
  state.board[a.r][a.c] = B; B.r=a.r; B.c=a.c; positionTile(B);
  state.board[b.r][b.c] = A; A.r=b.r; A.c=b.c; positionTile(A);

  // Handle special+special or color+anything combos as valid without match
  const specialComboResult = await trySpecialCombo(A,B);
  if(specialComboResult.done){
    state.inputLocked = false;
    return true;
  }

  // Check for matches
  const matches = findMatches();
  if(matches.length===0){
    // revert
    await wait(5);
    state.board[a.r][a.c] = A; A.r=a.r; A.c=a.c; positionTile(A);
    state.board[b.r][b.c] = B; B.r=b.r; B.c=b.c; positionTile(B);
    await wait(TRANSITION_MS);
    await badSwapAnimation(A,B);
    state.inputLocked = false;
    return false;
  }else{
    await resolveMatchesLoop(matches, {a, b});
    state.inputLocked = false;
    return true;
  }
}

async function trySpecialCombo(A,B){
  // Define behavior for combining specials.
  const aSpec = A.type!==Type.NORMAL;
  const bSpec = B.type!==Type.NORMAL;
  // Color bomb paired with any
  if(A.type===Type.COLOR && B.type===Type.COLOR){
    // clear board
    const cleared = new Set();
    for(let r=0;r<BOARD_ROWS;r++) for(let c=0;c<BOARD_COLS;c++) cleared.add(`${r},${c}`);
    state.score += SCORE_POWERUP_ACT*2;
    sounds.cascade(2);
    clearCells(cleared);
    await wait(TRANSITION_MS);
    await applyGravityAndRefill();
    await resolveAllCascades();
    updateAfterMove();
    return {done:true};
  }
  if(A.type===Type.COLOR && B.type!==Type.COLOR){
    const cleared = activateColorBomb(B.kind);
    state.score += SCORE_POWERUP_ACT;
    sounds.cascade(2);
    clearCells(cleared);
    await wait(TRANSITION_MS);
    await applyGravityAndRefill();
    await resolveAllCascades();
    updateAfterMove();
    return {done:true};
  }
  if(B.type===Type.COLOR && A.type!==Type.COLOR){
    const cleared = activateColorBomb(A.kind);
    state.score += SCORE_POWERUP_ACT;
    sounds.cascade(2);
    clearCells(cleared);
    await wait(TRANSITION_MS);
    await applyGravityAndRefill();
    await resolveAllCascades();
    updateAfterMove();
    return {done:true};
  }
  // Striped + Striped => clear row + column
  if((A.type===Type.STRIPED_H||A.type===Type.STRIPED_V) && (B.type===Type.STRIPED_H||B.type===Type.STRIPED_V)){
    const s1 = activateStriped(A);
    const s2 = activateStriped(B);
    const cleared = new Set([...s1, ...s2]);
    state.score += SCORE_POWERUP_ACT*2;
    sounds.cascade(2);
    clearCells(cleared);
    await wait(TRANSITION_MS);
    await applyGravityAndRefill();
    await resolveAllCascades();
    updateAfterMove();
    return {done:true};
  }
  // Striped + Bomb3 => row/col + 3x3
  if((A.type===Type.BOMB_3 && (B.type===Type.STRIPED_H||B.type===Type.STRIPED_V)) ||
     (B.type===Type.BOMB_3 && (A.type===Type.STRIPED_H||A.type===Type.STRIPED_V))){
    const cleared = new Set();
    const sA = (A.type===Type.BOMB_3)? activateBomb3(A) : activateStriped(A);
    const sB = (B.type===Type.BOMB_3)? activateBomb3(B) : activateStriped(B);
    sA.forEach(k=>cleared.add(k)); sB.forEach(k=>cleared.add(k));
    state.score += SCORE_POWERUP_ACT*2;
    sounds.cascade(2);
    clearCells(cleared);
    await wait(TRANSITION_MS);
    await applyGravityAndRefill();
    await resolveAllCascades();
    updateAfterMove();
    return {done:true};
  }
  // Color + Striped => turn all of that color into striped and trigger
  if((A.type===Type.COLOR && (B.type===Type.STRIPED_H||B.type===Type.STRIPED_V)) ||
     (B.type===Type.COLOR && (A.type===Type.STRIPED_H||A.type===Type.STRIPED_V))){
    const colorKind = (A.type===Type.COLOR)? B.kind : A.kind;
    const stripedType = (A.type===Type.STRIPED_H||B.type===Type.STRIPED_H) ? Type.STRIPED_H : Type.STRIPED_V;
    const cleared = activateAllOfKindTo(stripedType, colorKind);
    state.score += SCORE_POWERUP_ACT*3;
    sounds.cascade(3);
    clearCells(cleared);
    await wait(TRANSITION_MS);
    await applyGravityAndRefill();
    await resolveAllCascades();
    updateAfterMove();
    return {done:true};
  }
  // Color + Bomb3 => turn all color into Bomb3 and explode
  if((A.type===Type.COLOR && B.type===Type.BOMB_3) || (B.type===Type.COLOR && A.type===Type.BOMB_3)){
    const colorKind = (A.type===Type.COLOR)? B.kind : A.kind;
    const cleared = activateAllOfKindTo(Type.BOMB_3, colorKind);
    state.score += SCORE_POWERUP_ACT*3;
    sounds.cascade(3);
    clearCells(cleared);
    await wait(TRANSITION_MS);
    await applyGravityAndRefill();
    await resolveAllCascades();
    updateAfterMove();
    return {done:true};
  }
  // One special + anything else: allow activation on swap even without match
  if(aSpec ^ bSpec){
    const sp = aSpec? A : B;
    let cleared;
    if(sp.type===Type.STRIPED_H || sp.type===Type.STRIPED_V) cleared = activateStriped(sp);
    else if(sp.type===Type.BOMB_3) cleared = activateBomb3(sp);
    else return {done:false};
    state.score += SCORE_POWERUP_ACT;
    sounds.cascade(1);
    clearCells(cleared);
    await wait(TRANSITION_MS);
    await applyGravityAndRefill();
    await resolveAllCascades();
    updateAfterMove();
    return {done:true};
  }
  return {done:false};
}

async function resolveMatchesLoop(initialGroups, swapInfo){
  let groups = initialGroups;
  state.cascade = 0;
  while(groups && groups.length){
    const scoreGain = collectScoreForGroup(groups, state.cascade);
    state.score += scoreGain;
    sounds.match(state.cascade);
    const {toRemove, create} = planPowerups(groups, swapInfo);
    // Remove matched cells except where powerups will be created
    // Reserve creation cells: keep tile but will morph to special and others removed
    const reserved = new Set(create.map(p=>`${p.r},${p.c}`));
    const actualToRemove = new Set([...toRemove].filter(k=>!reserved.has(k)));
    clearCells(actualToRemove);
    // Morph reserved cells into powerups
    for(const cr of create){
      const t = state.board[cr.r][cr.c];
      if(!t) continue;
      t.type = cr.type;
      // keep its kind (for color bomb, kind is ignored)
      refreshGem(t);
      state.score += SCORE_POWERUP_ACT;
    }
    setStatus();
    await wait(TRANSITION_MS);
    await applyGravityAndRefill();
    // next cascade
    state.cascade++;
    sounds.cascade(state.cascade);
    groups = findMatches();
  }
  updateAfterMove();
}

async function resolveAllCascades(){
  let groups = findMatches();
  state.cascade = 0;
  while(groups.length){
    const scoreGain = collectScoreForGroup(groups, state.cascade);
    state.score += scoreGain;
    setStatus();
    const {toRemove, create} = planPowerups(groups, null);
    const reserved = new Set(create.map(p=>`${p.r},${p.c}`));
    const actualToRemove = new Set([...toRemove].filter(k=>!reserved.has(k)));
    clearCells(actualToRemove);
    for(const cr of create){
      const t = state.board[cr.r][cr.c];
      if(!t) continue;
      t.type = cr.type;
      refreshGem(t);
      state.score += SCORE_POWERUP_ACT;
    }
    await wait(TRANSITION_MS);
    await applyGravityAndRefill();
    state.cascade++;
    groups = findMatches();
  }
}

/* =========================
   ПОДСКАЗКИ
========================= */
function scheduleHint(){
  clearHint();
  state.hintTimer = setTimeout(()=>{
    const move = findAnyPossibleMove();
    if(move){
      state.hintPair = move;
      const [a,b] = move;
      const ta = state.board[a.r][a.c], tb = state.board[b.r][b.c];
      ta?.el.classList.add('hint');
      tb?.el.classList.add('hint');
    }
  }, HINT_DELAY_MS);
}
function clearHint(){
  if(state.hintTimer){ clearTimeout(state.hintTimer); state.hintTimer = null; }
  if(state.hintPair){
    const [a,b]=state.hintPair;
    state.board[a.r][a.c]?.el.classList.remove('hint');
    state.board[b.r][b.c]?.el.classList.remove('hint');
    state.hintPair=null;
  }
}

/* =========================
   UI / НАСТРОЙКИ / ХРАНИЛИЩЕ
========================= */
const newGameBtn = document.getElementById('newGameBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const pauseOverlay = document.getElementById('pauseOverlay');
const settingsBtn = document.getElementById('settingsBtn');
const settingsOverlay = document.getElementById('settings');
const settingsClose = document.getElementById('settingsClose');
const modeSelect = document.getElementById('modeSelect');
const themeSelect = document.getElementById('themeSelect');
const soundToggle = document.getElementById('soundToggle');
const soundBtn = document.getElementById('soundBtn');
const onboarding = document.getElementById('onboarding');
const helpOk = document.getElementById('helpOk');
const dontShowHelp = document.getElementById('dontShowHelp');
const gameOver = document.getElementById('gameOver');
const overText = document.getElementById('overText');
const overNew = document.getElementById('overNew');
const goalLabel = document.getElementById('goalLabel');
const goalStat = document.getElementById('goalStat');
const movesStat = document.getElementById('movesStat');
const timeStat = document.getElementById('timeStat');

let timerHandle = null;

function updateModeUI(){
  if(state.mode==='moves'){
    goalLabel.textContent = 'Цель:';
    goalStat.style.display = '';
    movesStat.style.display = '';
    timeStat.style.display = 'none';
  }else{
    goalLabel.textContent = 'Цель:';
    goalStat.style.display = '';
    movesStat.style.display = 'none';
    timeStat.style.display = '';
  }
}

function startTimer(){
  if(timerHandle) clearInterval(timerHandle);
  if(state.mode!=='timed') return;
  timerHandle = setInterval(()=>{
    if(!state.paused && !state.inputLocked){
      state.timeLeft = Math.max(0, state.timeLeft-1);
      setStatus();
      if(state.timeLeft===0){
        endGame(state.score>=state.target);
      }
    }
  }, 1000);
}

function pauseGame(set=true){
  state.paused = set;
  pauseOverlay.classList.toggle('show', set);
  pauseBtn.textContent = set ? 'Продолжить' : 'Пауза';
  pauseBtn.setAttribute('aria-pressed', set ? 'true':'false');
}

newGameBtn.addEventListener('click', ()=>{ sounds.button(); newGame(); });
pauseBtn.addEventListener('click', ()=>{ sounds.button(); pauseGame(!state.paused); });
resumeBtn.addEventListener('click', ()=>{ sounds.button(); pauseGame(false); });
settingsBtn.addEventListener('click', ()=>{ sounds.button(); openSettings(); });
settingsClose.addEventListener('click', ()=>{ sounds.button(); closeSettings(); });
soundBtn.addEventListener('click', ()=>{
  state.soundOn = !state.soundOn; sounds.button();
  soundBtn.textContent = state.soundOn ? 'Звук: Вкл' : 'Звук: Выкл';
  soundBtn.setAttribute('aria-pressed', state.soundOn?'true':'false');
  soundToggle.checked = state.soundOn;
  saveLocal();
});

function openSettings(){
  modeSelect.value = state.mode;
  themeSelect.value = state.theme;
  soundToggle.checked = state.soundOn;
  settingsOverlay.classList.add('show');
}
function closeSettings(){
  settingsOverlay.classList.remove('show');
  // apply
  const newMode = modeSelect.value;
  const newTheme = themeSelect.value;
  const newSound = soundToggle.checked;
  const modeChanged = newMode!==state.mode;
  state.mode = newMode; state.theme = newTheme; state.soundOn = newSound;
  applyTheme();
  saveLocal();
  updateModeUI();
  if(modeChanged) newGame();
}

helpOk.addEventListener('click', ()=>{
  onboarding.classList.remove('show');
  if(dontShowHelp.checked) localStorage.setItem('m3_hideHelp','1');
  sounds.button();
});
overNew.addEventListener('click', ()=>{ gameOver.classList.remove('show'); newGame(); });

function showHelpIfNeeded(){
  if(localStorage.getItem('m3_hideHelp')!=='1'){
    onboarding.classList.add('show');
  }
}

function endGame(win){
  state.paused = true;
  clearHint();
  const msg = win ? 'Победа!' : 'Не хватило очков';
  overText.textContent = `${msg} Ваш счёт: ${state.score}.`;
  gameOver.classList.add('show');
  if(state.score>state.best){ state.best = state.score; saveLocal(); }
  setStatus();
}

function updateAfterMove(){
  scheduleHint();
  if(state.mode==='moves'){
    state.movesLeft = Math.max(0, state.movesLeft-1);
    if(state.movesLeft===0) endGame(state.score>=state.target);
  }
  if(state.score>state.best){ state.best = state.score; }
  setStatus();
  selfCheck();
}

/* =========================
   КЛАВИАТУРА / ФОКУС
========================= */
boardSVG.addEventListener('keydown', (e)=>{
  if(state.paused || state.inputLocked) return;
  const focusEl = document.activeElement?.closest('.tile') || boardSVG.querySelector('.tile');
  const id = focusEl ? parseInt(focusEl.getAttribute('data-id'),10) : null;
  const t = id ? state.tilesById.get(id) : null;
  if(!t) return;

  let consumed = true;
  if(e.key==='ArrowLeft') moveFocus(t, 0, -1);
  else if(e.key==='ArrowRight') moveFocus(t, 0, 1);
  else if(e.key==='ArrowUp') moveFocus(t, -1, 0);
  else if(e.key==='ArrowDown') moveFocus(t, 1, 0);
  else if(e.key==='Enter' || e.key===' '){
    selectOrSwap(t);
  }else if(e.key==='Escape'){
    setSelected(null);
    announce('Выбор снят');
  }else consumed=false;
  if(consumed){ e.preventDefault(); }
});

function moveFocus(tile, dr, dc){
  const r = clamp(tile.r+dr, 0, BOARD_ROWS-1);
  const c = clamp(tile.c+dc, 0, BOARD_COLS-1);
  const t = state.board[r][c];
  t?.el.focus({preventScroll:true});
}

async function selectOrSwap(tile){
  clearHint();
  if(!state.selected){
    setSelected(tile);
    announce('Выбрано: ' + tileAriaLabel(tile));
    sounds.click();
  }else{
    const a = state.selected;
    const b = {r:tile.r, c:tile.c};
    const same = a.r===b.r && a.c===b.c;
    if(same){ setSelected(null); return; }
    if(!areNeighbors(a,b)){ setSelected(state.board[b.r][b.c]); return; }
    setSelected(null);
    await performSwap(a,b);
  }
  scheduleHint();
}

/* =========================
   ИНИЦИАЛИЗАЦИЯ И НОВАЯ ИГРА
========================= */
function resetBoardDOM(){
  while(boardSVG.firstChild) boardSVG.removeChild(boardSVG.firstChild);
}
function configureBoardElement(){
  boardSVG.setAttribute('width', TILE_SIZE*BOARD_COLS);
  boardSVG.setAttribute('height', TILE_SIZE*BOARD_ROWS);
  boardSVG.setAttribute('viewBox', `0 0 ${TILE_SIZE*BOARD_COLS} ${TILE_SIZE*BOARD_ROWS}`);
  boardSVG.setAttribute('aria-label', `Игровое поле ${BOARD_ROWS} на ${BOARD_COLS}`);
}

function newGame(){
  clearHint();
  state.rngSeed = Date.now() & 0x7fffffff;
  state.score = 0;
  state.target = TARGET_SCORE;
  state.movesLeft = MOVES_COUNT;
  state.timeLeft = TIMED_SECONDS;
  state.paused = false;
  state.inputLocked = false;
  state.selected = null;
  state.idCounter = 1;
  state.tilesById.clear();
  gameOver.classList.remove('show');
  pauseOverlay.classList.remove('show');
  resetBoardDOM();
  configureBoardElement();
  setCSSVars();
  setStatus();
  updateModeUI();
  generateBoard();
  startTimer();
  scheduleHint();
}

/* =========================
   САМООТЛАДКА / ТЕСТЫ
========================= */
function hasAnyMatches(){
  return findMatches().length>0;
}
function hasAnyMove(){
  return !!findAnyPossibleMove();
}
function boardFilled(){
  for(let r=0;r<BOARD_ROWS;r++) for(let c=0;c<BOARD_COLS;c++) if(!state.board[r][c]) return false;
  return true;
}
function selfCheck(){
  const ok = boardFilled() && hasAnyMove() && !hasAnyMatches();
  console.log('%cSelf-check:', 'color:#09f', ok ? 'OK' : 'REQUIRES_ATTENTION', {boardFilled:boardFilled(), hasAnyMove:hasAnyMove(), hasAnyMatches:hasAnyMatches()});
}

/* =========================
   ТАЙМЕР БЕЗДЕЙСТВИЯ ДЛЯ ПОДСКАЗОК
========================= */
['click','keydown','touchstart'].forEach(evt=>{
  window.addEventListener(evt, ()=>{ scheduleHint(); }, {passive:true});
});

/* =========================
   СТАРТ
========================= */
(function init(){
  loadLocal(); applyTheme(); setCSSVars(); setStatus(); updateModeUI();
  soundBtn.textContent = state.soundOn ? 'Звук: Вкл' : 'Звук: Выкл';
  soundBtn.setAttribute('aria-pressed', state.soundOn?'true':'false');
  document.getElementById('goal').textContent = TARGET_SCORE;
  document.getElementById('moves').textContent = MOVES_COUNT;
  document.getElementById('time').textContent = timeFormat(TIMED_SECONDS);
  configureBoardElement();
  generateBoard();
  showHelpIfNeeded();
  startTimer();
  scheduleHint();
})();

</script>
</body>
</html>
